---
title: Последовательности
sidebar: Документация
---

Clojure определяет многие алгоритмы в терминах последовательностей (`seq`). `Seq` - это логический список, и в отличие от большинства лисперов, где список представлен конкретной двухслотовой структурой, Clojure использует интерфейс `ISeq`, позволяющий многим структурам данных предоставлять доступ к своим элементам в виде последовательностей. Функция [seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq) выдает реализацию `ISeq`, соответствующую коллекции. Последовательности отличаются от итераторов тем, что они являются постоянными и неизменяемыми, а не курсорами состояния коллекции. Как таковые, они полезны для гораздо большего, чем `foreach` - функции могут потреблять и производить `seq`, они потокобезопасны, могут разделять структуру и т.д.

Большинство функций библиотеки последовательностей являются _ленивыми_, т.е. функции, возвращающие seq, делают это постепенно, по мере их потребления, и, таким образом, потребляют любые аргументы seqs также постепенно. Функции, возвращающие ленивые seq, могут быть реализованы с помощью макроса [lazy-seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/lazy-seq). См. также [lazy](lazy).

Когда [seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq) используется для объектов, реализующих `Iterable`, результирующая последовательность остается неизменяемой и постоянной, и будет представлять собой один проход по данным. Поскольку этот проход может происходить лениво, он может увидеть изменения, произошедшие после вызова [seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq). Кроме того, если подкрепляющий итератор подвержен `ConcurrentModificationException`, то и результирующий `seq` тоже. Когда seq используется с массивами Java, изменения в базовом массиве будут отражены в seq - для получения полной неизменяемости необходимо скопировать исходный массив. Тем не менее, использование seq для итерабельных массивов и массивов по-прежнему очень полезно, поскольку seq поддерживают многопроходные и ленивые алгоритмы. Надежные программы не должны мутировать массивы или `Iterables`, на которых есть seq.

Многие функции библиотеки seq берут одну или несколько коллекций, вызывают для них [seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq), а затем работают с полученным seq. Другими словами, многие из этих функций берут коллекции, но работают с их секвенциями.

## Интерфейс Seq

### (_first_ coll)

Возвращает первый элемент в коллекции. Вызывает функцию `seq` на своем аргументе. Если `coll` равен `nil`, возвращает `nil`.

### (_rest_ coll)

Возвращает последовательность элементов после первого. Вызывает seq на своем аргументе. Если элементов больше нет, возвращает логическую последовательность, для которой `seq` возвращает `nil`.

### (_cons_ item seq)

Возвращает новый `seq`, где `item` - первый элемент, а `seq` - остальные.

Для обсуждения **rest** против **next** и **lazy-seq** смотрите [lazy](lazy).

## Библиотека Seq

Это выборка основных функций последовательности, сгруппированных по их возможностям. Некоторые функции могут использоваться по-разному и поэтому представлены в нескольких группах. Многие другие перечислены в разделе [API](https://clojure.github.io/clojure/).

Начиная с версии Clojure 1.7, Clojure также предоставляет [трансдьюсеры](transducers), альтернативную модель для композиционных преобразований коллекций. Трансдьюсеры разделяют входную, обрабатывающую и выходную части преобразования и позволяют повторно использовать преобразования в большем количестве контекстов, например, в каналах `core.async`. Многие функции последовательности из приведенного ниже списка создают трансдьюсеры, если входная коллекция опущена. Более подробную информацию см. на странице трансдьюсеры.

### Seq in, Seq out

Более короткий seq из более длинного seq: [distinct](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/distinct) [filter](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/filter) [remove](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/remove) [for](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/for) [keep](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/keep) [keep-indexed](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/keep-indexed)  
Более длинный seq из более короткого seq: [cons](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/cons) [concat](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/concat) [lazy-cat](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/lazy-cat) [mapcat](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/mapcat) [cycle](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/cycle) [interleave](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/interleave) [interpose](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/interpose)  
Секвенция с отсутствующими головными элементами: [rest](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/rest) [next](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/next) [fnext](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/fnext) [nnext](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/nnext) [drop](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop) [drop-while](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop-while) [nthnext](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/nthnext) [for](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/for)  
Секвенция с отсутствующими хвостовыми элементами: [take](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take) [take-nth](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take-nth) [take-while](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take-while) [butlast](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/butlast) [drop-last](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/drop-last) [for](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/for)  
Перестановка последовательности: [flatten](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/flatten) [reverse](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reverse) [sort](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sort) [sort-by](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sort-by) [shuffle](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/shuffle)  
Создание вложенных секвенций: [split-at](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/split-at) [split-with](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/split-with) [partition](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/partition) [partition-all](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/partition-all) [partition-by](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/partition-by)  
Обработка каждого элемента seq для создания нового seq: [map](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/map) [pmap](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/pmap) [mapcat](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/mapcat) [for](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/for) [replace](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/replace) [reductions](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reductions) [map-indexed](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/map-indexed) [seque](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seque)

### Использование последовательности

Извлечение элемента с определенным номером из последовательности: [first](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/first) [ffirst](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/ffirst) [nfirst](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/nfirst) [second](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/second) [nth](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/nth) [when-first](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/when-first) [last](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/last) [rand-nth](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/rand-nth)  
Создайте коллекцию из seq: [zipmap](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/zipmap) [into](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/into) [reduce](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reduce) [set](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/set) [vec](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/vec) [into-array](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/into-array) [to-array-2d](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/to-array-2d) [frequencies](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/frequencies) [group-by](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/group-by)  
Передать элементы последовательности в качестве аргументов функции: [apply](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/apply)  
Вычислить логическое число из seq: [not-empty](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/not-empty) [some](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/some) [reduce](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/reduce) [seq?](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq?) [every?](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/every?) [not-every?](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/not-every?) [not-any?](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/not-any?) [empty?](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/empty?)  
Поиск последовательности с использованием предиката: [some](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/some) [filter](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/filter)  
Принудительная оценка ленивых секвенций: [doseq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/doseq) [dorun](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/dorun) [doall](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/doall)  
Проверить, были ли ленивые секвенции принудительно вычислены до конца: [realized?](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/realized?)

### Создание последовательности

Ленивый seq из коллекции: [seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/seq) [vals](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/vals) [keys](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/keys) [rseq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/rseq) [subseq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/subseq) [rsubseq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/rsubseq)  
Ленивый seq из функции: [lazy-seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/lazy-seq) [repeatedly](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/repeatedly) [iterate](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/iterate)  
Ленивый запрос от константы: [repeat](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/repeat) [range](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/range)  
Ленивое выделение из других объектов: [line-seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/line-seq) [resultset-seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/resultset-seq) [re-seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/re-seq) [tree-seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/tree-seq) [file-seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/file-seq) [xml-seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/xml-seq) [iterator-seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/iterator-seq) [enumeration-seq](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/enumeration-seq)
)
